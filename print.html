<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Keramik</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="environment.html"><strong aria-hidden="true">1.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="create_cluster.html"><strong aria-hidden="true">2.</strong> Creating a Cluster</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deploy_keramik.html"><strong aria-hidden="true">2.1.</strong> Deploying Keramik</a></li><li class="chapter-item expanded "><a href="setup_network.html"><strong aria-hidden="true">2.2.</strong> Setup Network</a></li></ol></li><li class="chapter-item expanded "><a href="simulation.html"><strong aria-hidden="true">3.</strong> Running a Simulation</a></li><li class="chapter-item expanded "><a href="analysis.html"><strong aria-hidden="true">4.</strong> Analyzing Simulation Runs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datadog.html"><strong aria-hidden="true">4.1.</strong> Analysis with Datadog</a></li></ol></li><li class="chapter-item expanded "><a href="developing.html"><strong aria-hidden="true">5.</strong> Developing Keramik</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developing_operator.html"><strong aria-hidden="true">5.1.</strong> Operator</a></li><li class="chapter-item expanded "><a href="developing_runner.html"><strong aria-hidden="true">5.2.</strong> Runner</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">6.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_configuration.html"><strong aria-hidden="true">6.1.</strong> Advanced CAS and Ceramic Configuration</a></li><li class="chapter-item expanded "><a href="monitoring.html"><strong aria-hidden="true">6.2.</strong> Monitoring</a></li><li class="chapter-item expanded "><a href="ipfs.html"><strong aria-hidden="true">6.3.</strong> IPFS</a></li><li class="chapter-item expanded "><a href="mixed_networks.html"><strong aria-hidden="true">6.4.</strong> Mixed Networks</a></li><li class="chapter-item expanded "><a href="secrets.html"><strong aria-hidden="true">6.5.</strong> Secrets</a></li><li class="chapter-item expanded "><a href="operator.html"><strong aria-hidden="true">6.6.</strong> Operator Design</a></li><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">6.7.</strong> Migration Tests</a></li><li class="chapter-item expanded "><a href="advanced_bootstrap.html"><strong aria-hidden="true">6.8.</strong> Custom Bootstrap Configuration</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Keramik</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="environment"><a class="header" href="#environment">Environment</a></h1>
<p>Keramik can be setup in a <a href="environment.html#local-environment">local</a> or <a href="environment.html#eks-environment">eks</a> environment.</p>
<h2 id="local-environment"><a class="header" href="#local-environment">Local Environment</a></h2>
<p>Requires</p>
<ul>
<li><a href="https://rustup.rs/">rust</a></li>
<li><a href="https://kind.sigs.k8s.io/">kind</a></li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a></li>
<li><a href="https://docs.docker.com/get-docker/">docker</a></li>
<li><a href="https://grpc.io/docs/protoc-installation/">protoc</a></li>
</ul>
<p>When using a local environment, you will need to <a href="./create_cluster.html">create a cluster</a></p>
<h2 id="eks"><a class="header" href="#eks">EKS</a></h2>
<p>Requires</p>
<ul>
<li><a href="https://eksctl.io/introduction/#installation">eks - https://eksctl.io/introduction/#installation</a></li>
<li><a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">aws cli - https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html</a></li>
</ul>
<p>Once these are installed, you will need to login with aws cli via sso</p>
<pre><code class="language-shell">aws configure sso
</code></pre>
<p>You will need to use <code>https://3box.awsapps.com/start/</code> for the sso url with region <code>us-east-2</code>. Use account
<code>Benchmarking</code> with role <code>AWSAdministratorAccess</code>. It is recommended to rename the profile to <code>keramik</code> or <code>benchmarking</code>.</p>
<p>You can now find namespaces with</p>
<pre><code class="language-shell">aws eks update-kubeconfig --region=us-east-1 --profile=keramik --name=benchmarking-ceramic
</code></pre>
<p>When using an eks environment, you <em>do not</em> need to create a cluster. You will need to <a href="./setup_network.html">setup a network</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-cluster"><a class="header" href="#creating-a-cluster">Creating a Cluster</a></h1>
<p>Kind (Kubernetes in Docker) runs a local k8s cluster. Create and initialize a new kind cluster using this configuration:</p>
<pre><code class="language-yaml"># kind.yaml
---
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
featureGates:
  MaxUnavailableStatefulSet: true
</code></pre>
<p>This configuration enables a feature that allows stateful sets to more rapidly redeploy pods on changes.
While not required to use keramik it makes deploying and mutating networks significantly faster.</p>
<pre><code class="language-shell"># Create a new kind cluster (i.e. local k8s)
kind create cluster --config kind.yaml
</code></pre>
<p>Now you will need to <a href="./deploy_keramik.html">deploy Keramik</a> to the cluster.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-keramik"><a class="header" href="#deploy-keramik">Deploy Keramik</a></h1>
<p>To deploy keramik, we will need to deploy custom resource definitions (CRDs) and apply the Keramik operator.</p>
<h2 id="deploy-crds"><a class="header" href="#deploy-crds">Deploy CRDS</a></h2>
<p>Custom resource definitions tell k8s about our network and simulation resources.
When deploying a new cluster and anytime they change you need to apply them:</p>
<pre><code class="language-shell">cargo run --bin crdgen | kubectl apply -f -
</code></pre>
<h2 id="deploy-keramik--operator"><a class="header" href="#deploy-keramik--operator">Deploy Keramik  Operator</a></h2>
<p>The last piece to running Keramik is the operator itself. Apply the operator into the <code>keramik</code> namespace.</p>
<pre><code># Create keramik namespace
kubectl create namespace keramik
# Apply the keramik operator
kubectl apply -k ./k8s/operator/
</code></pre>
<p>Once that is complete, you can now <a href="./setup_network.html">setup a network</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-network"><a class="header" href="#setting-up-a-network">Setting Up a Network</a></h1>
<p>With the operator running we can now define a Ceramic network.</p>
<p>Place the following network definition into the file <code>small.yaml</code>.</p>
<pre><code class="language-yaml"># small.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: &lt;unique-name&gt;-small
spec:
  replicas: 2
  # Required if you plan to run a simulation
  monitoring:
    namespaced: true
</code></pre>
<p>The <code>&lt;unique-name&gt;</code> can be any unique string, your initials are a good default if you are deploying the network to a cloud cluster.</p>
<p>Apply this network definition to the k8s cluster:</p>
<pre><code class="language-shell">kubectl apply -f small.yaml
</code></pre>
<p>After a minute or two you should have a functioning Ceramic network.</p>
<h2 id="checking-the-status-of-the-network"><a class="header" href="#checking-the-status-of-the-network">Checking the status of the network</a></h2>
<p>Check the status of the network:</p>
<pre><code class="language-shell">export NETWORK_NAME=&lt;unique-name&gt;-small
kubectl describe network $NETWORK_NAME
</code></pre>
<p>Keramik places each network into its own namespace named after the name of the network. You can default your context
to this namespace using:</p>
<pre><code class="language-shell">kubectl config set-context --current --namespace=keramik-$NETWORK_NAME
</code></pre>
<p>Inspect the pods within the network using:</p>
<pre><code class="language-shell">kubectl get pods
</code></pre>
<blockquote>
<p>HINT: Use tools like  <a href="https://k9scli.io/">k9s</a> to interactively manage your network.</p>
</blockquote>
<p>When your pods are ready, you can <a href="./simulation.html">run a simulation</a>.
If you are running locally, be patient as the first time you setup a network you will need to download several images.</p>
<blockquote>
<p>HINT: Use tools like <a href="https://github.com/ahmetb/kubectx">kubectx</a> or <a href="https://github.com/sbstp/kubie">kubie</a> to work with multiple namespaces and contexts.</p>
</blockquote>
<p>When you're finished, you can tear down your network with the following command:</p>
<pre><code class="language-shell">kubectl delete network $NETWORK_NAME
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulation"><a class="header" href="#simulation">Simulation</a></h1>
<p>To run a simulation, first define a simulation. Available simulation types are</p>
<ul>
<li><code>ipfs-rpc</code> - A simple simulation that writes and reads to IPFS</li>
<li><code>ceramic-simple</code> - A simple simulation that writes and reads events to two different streams, a small and large model</li>
<li><code>ceramic-write-only</code> - A simulation that only performs updates on two different streams</li>
<li><code>ceramic-new-streams</code> - A simulation that only creates new streams</li>
<li><code>ceramic-model-reuse</code> - A simulation that reuses the same model and queries instances across workers</li>
<li><code>recon-event-sync</code> - A simulation that creates events for Recon to sync at a fixed rate (~300/s by default). Designed for a 2 node network but should work on any.</li>
</ul>
<p>Using one of these scenarios, we can then define the configuration for that scenario:</p>
<pre><code class="language-yaml"># basic.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Simulation
metadata:
  name: basic
  # Must be the same namespace as the network to test
  namespace: keramik-&lt;unique-name&gt;-small
spec:
  scenario: ceramic-simple
  devMode: true # optional to remove container resource limits and requirements for local benchmarking
  users: 10
  runTime: 4
</code></pre>
<p>If you want to run it against a defined network, set the namespace to the same as the network. in this example the
namespace is set to the same network applied when <a href="./setup_network.html">the network was setup</a>.
Additionally, you can define the scenario you want to run, the number of users to run for each node, and the number of minutes it will run.</p>
<p>Before running the simulation make sure the <code>network</code> is ready and has <a href="./monitoring.html">monitoring</a> enabled.</p>
<pre><code>kubectl describe network &lt;unique-name&gt;-small
</code></pre>
<p>You should see that the number of <code>Ready Replicas</code> is the same as the <code>Replicas</code>.
Example simplified output of a ready network:</p>
<pre><code class="language-txt">Name:         nc-small
...
  Ready Replicas:  2
  Replicas:        2
...
</code></pre>
<p>Once ready, apply this simulation defintion to the k8s cluster:</p>
<pre><code class="language-shell">kubectl apply -f basic.yaml
</code></pre>
<p>Keramik will first start all the metrics and tracing resources, once ready it will start the simulation by first starting the simulation manager and then all the workers.
The manager and workers will stop once the simulation is complete.</p>
<p>You can then <a href="analysis.html">analyze</a> the results of the simulation.</p>
<p>If you want to rerun a simulation with no changes, you can delete the simulation and reapply it.</p>
<pre><code class="language-shell">kubectl delete -f basic.yaml
</code></pre>
<h2 id="simulating-specific-versions"><a class="header" href="#simulating-specific-versions">Simulating Specific Versions</a></h2>
<p>Often you will want to run a simulation against a specific version of software.
To do this you will need to build the image and configure your network to run that image.</p>
<h3 id="example-custom-js-ceramic-image"><a class="header" href="#example-custom-js-ceramic-image">Example Custom JS-Ceramic Image</a></h3>
<p>Use this example <code>network</code> definition with a custom <code>js-ceramic</code> image.</p>
<pre><code class="language-yaml"># custom-js-ceramic.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: custom-js-ceramic
spec:
  replicas: 2
  monitoring:
    namespaced: true
  ceramic:
    - image: ceramicnetwork/composedb:dev
      imagePullPolicy: IfNotPresent
</code></pre>
<pre><code class="language-shell">kubectl apply -f custom-js-ceramic.yaml
</code></pre>
<p>You can also run <a href="./mixed_networks.html">mixed networks</a> and various other <a href="./advanced_configuration.html">advanced</a> configurations.</p>
<h3 id="example-custom-ipfs-image"><a class="header" href="#example-custom-ipfs-image">Example Custom IPFS Image</a></h3>
<p>Use this example <code>network</code> definition with a custom <code>IPFS</code> image.</p>
<pre><code class="language-yaml"># custom-ipfs.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: custom-ipfs
spec:
  replicas: 2
  monitoring:
    namespaced: true
  ceramic:
    - ipfs:
        rust:
          image: ceramicnetwork/rust-ceramic:dev
          imagePullPolicy: IfNotPresent
</code></pre>
<pre><code class="language-shell">kubectl apply -f custom-ipfs.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis"><a class="header" href="#analysis">Analysis</a></h1>
<p>Analysis of Keramik results depends on the purpose of the simulation. You may want to just see average latencies, or dive
deeper into reported metrics. For profiling, you will want to use <a href="./datadog.html">datadog</a>.</p>
<h2 id="quick-log-analysis"><a class="header" href="#quick-log-analysis">Quick Log Analysis</a></h2>
<p>The simulation manager provides a very quick way to analyze the logs of a simulation run. You will need to know the name
of the manager pod though. You will first need to see if the <code>simulate-manager</code> pod has completed, by running</p>
<pre><code>kubectl get pods
</code></pre>
<p>If the pod has completed and is no longer in that list, you can see recently terminated pods using:</p>
<pre><code>kubectl get event -o custom-columns=NAME:.metadata.name | cut -d &quot;.&quot; -f1
</code></pre>
<p>Once you have the name of the manager, you can retrieve its logs</p>
<pre><code>kubectl logs simulate-manager-&lt;id&gt;
</code></pre>
<p>If the <code>simulate-manager</code> pod is not in your pod list, you may need to get logs with the <code>--previous</code> flag:</p>
<pre><code>kubectl logs --previous simulate-manager-&lt;id&gt;
</code></pre>
<h2 id="analysis-with-duckdb-or-jupyter"><a class="header" href="#analysis-with-duckdb-or-jupyter">Analysis with DuckDB or Jupyter</a></h2>
<p>First you will need to install a few things:</p>
<pre><code>pip install duckdb duckdb-engine pandas jupyter jupysql matplotlib
</code></pre>
<p>To analyze the results of a simulation first copy the metrics-TIMESTAMP.parquet file from the otel-0 pod.
First restart opentelemetry-0 pod so it writes out the parquet file footer.</p>
<pre><code>kubectl delete pod opentelemetry-0
kubectl wait --for=condition=Ready pod/opentelemetry-0 # make sure pod has restarted
kubectl exec opentelemetry-0 -- ls -la /data # List files in the directly find the TIMESTAMP you need
kubectl cp opentelemetry-0:data/metrics-TIMESTAMP.parquet ./analyze/metrics.parquet
cd analyze
</code></pre>
<p>Use duckdb to examine the data:</p>
<pre><code>duckdb
&gt; SELECT * FROM 'metrics.parquet' LIMIT 10;
</code></pre>
<p>Alternatively start a jupyter notebook using <code>analyze/sim.ipynb</code>:</p>
<pre><code>jupyter notebook
</code></pre>
<h2 id="comparing-simulation-runs"><a class="header" href="#comparing-simulation-runs">Comparing Simulation Runs</a></h2>
<p>How do we conclude a simulation is better or worse that another run?</p>
<p>Each simulation will likely be targeting a specific result however there are common results we should expect to see.</p>
<p>Changes should not make correctness worse. Correctness is defined using two metrics:</p>
<ul>
<li>Percentage of events successfully persisted on the node that accepted the initial write.</li>
<li>Percentage of events successfully replicated on nodes that observed the writes via the Ceramic protocol.</li>
</ul>
<p>Changes should not make performance worse. Performance is defined using these metrics:</p>
<ul>
<li>Writes/sec across all nodes in the cluster and by node</li>
<li>p50,p90,p95,p99 and p99.9 of the duration of writes across all nodes in the cluster and by node</li>
<li>Success/failure ratio of writes requests across all nodes in the cluster and by node</li>
<li>p50,p90,p95,p99 and p99.9 of duration of time to become replicated. The time from when one node accepts the write to when another node has the same write available for read.</li>
</ul>
<p>For any simulation of the Ceramic protocol these metrics should apply. Any report about the results of a simulation should include these metrics and we compare them against the established a baseline.</p>
<h2 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h2>
<p>In addition to the above, we can also use <a href="./datadog.html">datadog</a> to dive further into performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datadog"><a class="header" href="#datadog">Datadog</a></h1>
<p>Keramik can also be configured to send metrics and telemetry data to datadog.</p>
<p>You will first need to <a href="setup_network.html">setup a barebones network</a> that we can install the datadog operator
into. An example barebones network from the above setup:</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: &lt;name of network&gt;
spec:
  replicas: 1
  datadog:
    enabled: true
    version: &quot;unique_value&quot;
    profilingEnabled: true
</code></pre>
<p>You will need to install the datadog k8s operator into the network. This requires
<a href="https://helm.sh/docs/intro/install/">installing</a> <code>helm</code>, there doesn't seem to be any other way to install the operator
without first installing helm. However once the datadog operator is installed helm is no longer needed.</p>
<pre><code>helm repo add datadog https://helm.datadoghq.com
helm install my-datadog-operator datadog/datadog-operator
</code></pre>
<p>Now we will use that barebones network to setup secrets for datadog, and the datadog agent. Adjust the previously 
defined network definition to look like the following:</p>
<pre><code class="language-yaml"># Network setup
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  datadog:
    enabled: true
    version: &quot;unique_value&quot;
    profilingEnabled: true
    
# Secrets Setup
---
apiVersion: v1
kind: Secret
metadata:
  name: datadog-secret
type: Opaque
stringData:
  api-key: &lt;Datadog API Key Secret&gt;
  app-key: &lt;Datadog Application Key Secret&gt;
    
# Datadog Agent setup
---
kind: DatadogAgent
apiVersion: datadoghq.com/v2alpha1
metadata:
  name: datadog
spec:
  global:
    kubelet:
      tlsVerify: false
    site: us3.datadoghq.com
    credentials:
      apiSecret:
        secretName: datadog-secret
        keyName: api-key
      appSecret:
        secretName: datadog-secret
        keyName: app-key
  override:
    clusterAgent:
      image:
        name: gcr.io/datadoghq/cluster-agent:latest
    nodeAgent:
      image:
        name: gcr.io/datadoghq/agent:latest
  features:
    npm:
      enabled: true
    apm:
      enabled: true
      hostPortConfig:
        enabled: true
</code></pre>
<p>The Datadog API Key is found at the organization level, and should be the secret associated with the API Key. The 
Datadog application key can be found at the organization or user level, and should be the secret associated with the
application key.</p>
<p>You can now apply this with</p>
<pre><code>kubectl apply -f network.yaml
</code></pre>
<p><em>Note</em> If you are running locally, you will need to restart your CAS and Ceramic pods using</p>
<pre><code>kubectl delete pod ceramic-0 ceramic-1 cas-0
</code></pre>
<p>where the ceramic pods will depend on the replicas used. Make sure you delete all Ceramic and CAS pods. This only needs 
to be done the </p>
<p>Anytime you need to change the network, change this file, then reapply it with</p>
<pre><code>kubectl apply -f network.yaml
</code></pre>
<p>Telemetry data sent to datadog will have two properties to uniquely identifiy the data from other keramik networks.</p>
<ul>
<li><code>env</code> - this is set based on the namespace of the keramik network.</li>
<li><code>version</code> - specified in the datadog config, may be any unique value.</li>
</ul>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<pre><code>kubectl delete -f network.yaml
helm delete my-datadog-operator
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-keramik"><a class="header" href="#developing-keramik">Developing Keramik</a></h1>
<p>When you need to add features to Keramik networks or simulations you will need to run local builds of the operator and the runner.</p>
<ul>
<li><a href="./developing_operator.html">Operator</a> - long lived process that manages the network custom resource.</li>
<li><a href="./developing_runner.html">Runner</a> - short lived process that performs various tasks within the network (i.e. bootstrapping)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator"><a class="header" href="#operator">Operator</a></h1>
<p>The <code>operator</code> automates creating and manipulating networks via custom resource definition.
Any changes to the operator require that you rebuild it and load it into kind again.</p>
<pre><code class="language-shell">docker buildx build --load -t keramik/operator:dev --target operator .
kind load docker-image keramik/operator:dev
</code></pre>
<p>Now we need to update the k8s operator definition to use our new image:</p>
<p>Edit <code>./k8s/operator/kustomization.yaml</code> to use the <code>dev</code> tag</p>
<pre><code class="language-yaml">images:
  - name: keramik/operator
    newTag: dev
</code></pre>
<p>Edit <code>./k8s/operator/manifests/operator.yaml</code> to use <code>IfNotPresent</code> for the <code>imagePullPolicy</code>.</p>
<pre><code class="language-yaml"># ...
      containers:
      - name: keramik-operator
        image: &quot;keramik/operator&quot;
        imagePullPolicy: IfNotPresent
# ...
</code></pre>
<p>Update the CRD definitions and apply the Keramik operator:</p>
<pre><code class="language-shell">cargo run --bin crdgen | kubectl apply -f -
kubectl apply -k ./k8s/operator/
</code></pre>
<p>See the <a href="./operator.html">operator background</a> for details on certain design patterns of the operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runner"><a class="header" href="#runner">Runner</a></h1>
<p>The <code>runner</code> is a utility for running various jobs to initialize the network and run workloads against it.
Currently the runner provides two utilites:</p>
<ul>
<li>Bootstrap nodes</li>
<li>Run simulations</li>
</ul>
<p>If you intend to develop either of these features you will need to build the runner image and configure your network or simulation to use your local image.</p>
<h2 id="build-and-load-the-runner-image"><a class="header" href="#build-and-load-the-runner-image">Build and Load the Runner Image</a></h2>
<p>The <code>runner</code> is a utility for running various jobs to initialize the network and run workloads against it.
Any changes to the runner require that you rebuild it and load it into kind again.</p>
<pre><code class="language-shell">docker buildx build --load -t keramik/runner:dev --target runner .
kind load docker-image keramik/runner:dev
</code></pre>
<h2 id="setup-network-with-runner-image"><a class="header" href="#setup-network-with-runner-image">Setup network with Runner Image</a></h2>
<p>To use a custom runner image when you <a href="./setup_network.html">setup your network</a>, you will need to adjust the yaml you
use to specify how to bootstrap the runner.</p>
<pre><code class="language-yaml"># small.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  # Use custom runner image for bootstrapping
  bootstrap:
    image: keramik/runner:dev
    imagePullPolicy: IfNotPresent
</code></pre>
<h2 id="setup-simulation-with-runner-image"><a class="header" href="#setup-simulation-with-runner-image">Setup simulation with Runner Image</a></h2>
<p>You will also need to specify the image in your <a href="./simulation.html">simulation</a> yaml.</p>
<pre><code class="language-yaml"># Custom runner
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Simulation
metadata:
  name: basic
  namespace: keramik-small
spec:
  scenario: ceramic-simple
  users: 10
  runTime: 4
  image: keramik/runner:dev
  imagePullPolicy: IfNotPresent
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>For more advanced usage of keramik, please see</p>
<ul>
<li><a href="./advanced_configuration.html">Advanced CAS and Ceramic Configuration</a></li>
<li><a href="./monitoring.html">Monitoring</a></li>
<li><a href="./ipfs.html">IPFS</a></li>
<li><a href="./mixed_networks.html">Mixed Networks</a></li>
<li><a href="./secrets.html">Secrets</a></li>
<li><a href="./operator.html">Operator Design</a></li>
<li><a href="./migration.html">Migration Tests</a></li>
<li><a href="./advanced_bootstrap.html">Custom Bootstrap Configuration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-cas-and-ceramic-configuration"><a class="header" href="#advanced-cas-and-ceramic-configuration">Advanced CAS and Ceramic Configuration</a></h1>
<p>By default, Keramik will instantiate all the resources required for a functional CAS service, including a Ganache
blockchain.</p>
<p>You can configure the Ceramic nodes to use an external instance of the CAS instead of one inside the cluster. If using a
CAS running in 3Box Labs infrastructure, you will also need to specify the Ceramic network type associated with the
node, e.g. <code>dev-unstable</code>.</p>
<p>You may also specify an Ethereum RPC endpoint for the Ceramic nodes to be able to verify anchors, or set it to an empty
string to clear it from the Ceramic configuration. In the latter case, the Ceramic nodes will come up but will not be
able to verify anchors.</p>
<p>If left unspecified, <code>networkType</code> will default to <code>local</code>, <code>ethRpcUrl</code> to <code>http://ganache:8545</code>,
and <code>casApiUrl</code> to <code>http://cas:8081</code>. These defaults point to an internal CAS using a local
pubsub topic in a fully isolated network.</p>
<p>Additionally IPFS can be <a href="./ipfs.html">configured</a> with custom images and resources for both CAS and Ceramic.</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  privateKeySecret: &quot;small&quot;
  networkType: &quot;dev-unstable&quot;
  ethRpcUrl: &quot;&quot;
  casApiUrl: &quot;https://some-anchor-service.com&quot;
</code></pre>
<h1 id="adjusting-ceramic-environment"><a class="header" href="#adjusting-ceramic-environment">Adjusting Ceramic Environment</a></h1>
<p>Ceramic environment can be adjusted by specifying environment variables in the network configuration</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  ceramic:
    - env:
        CERAMIC_PUBSUB_QPS_LIMIT: &quot;500&quot;
</code></pre>
<h1 id="disabling-aws-functionality"><a class="header" href="#disabling-aws-functionality">Disabling AWS Functionality</a></h1>
<p>Certain functionality in CAS depends on AWS services. If you are running Keramik in a non-AWS environment, you can
disable this by editing the statefulset for CAS</p>
<pre><code>kubectl edit statefulsets cas
</code></pre>
<p>and adding the following environment variables to the <code>spec/template/spec/containers/env</code> config:</p>
<pre><code class="language-yaml">- name: SQS_QUEUE_URL
  value: &quot;&quot;
- name: MERKLE_CAR_STORAGE_MODE
  value: disabled
</code></pre>
<p><em>Note</em> statefulsets must be edited every time the network is recreated.</p>
<h1 id="image-resources"><a class="header" href="#image-resources">Image Resources</a></h1>
<p>During local benchmarking, you may not have enough resources to run the cluster. A simple &quot;fix&quot; is to use the <code>devMode</code> flag on the network and simulation specs. This will override the resource requests and limits values to be none, which means it doesn't need available resources to deploy, and can consume as much as it desires. This would be problematic in production and should only be used for testing purposes.</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  devMode: true # ceramic will require specified resources but all other containers will be unconstrained
  ceramic:
    - resourceLimits:
        cpu: &quot;1&quot;
        memory: &quot;1Gi&quot;
        storage: &quot;1Gi&quot;
</code></pre>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  ceramic:
    - resourceLimits:
        cpu: &quot;4&quot;
        memory: &quot;8Gi&quot;
        storage: &quot;2Gi&quot;
</code></pre>
<p>The above yaml will provide each ceramic pod with 4 cpu cores, 8GB of memory, and 2GB of storage. Dependent on the system you 
are running on you may run out of resources. You can check your resource usage with</p>
<pre><code class="language-shell">kubectl describe nodes
</code></pre>
<p>You can also set resources for IPFS within ceramic similarly.</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  ceramic:
    - ipfs:
       go:
         resourceLimits:
           cpu: &quot;4&quot;
           memory: &quot;8Gi&quot;
           storage: &quot;2Gi&quot;
         storageClass: &quot;fastDisk&quot;
</code></pre>
<p>Additionally the storage class can be set. The storage class must be created out of band but can be referenced as above.</p>
<p>Setting resources for CAS is slightly different, using <code>casResourceLimits</code> to set CAS resources</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  cas:
    image: ceramicnetwork/ceramic-anchor-service:latest
    casResourceLimits:
      cpu: &quot;250m&quot;
      memory: &quot;1Gi&quot;
</code></pre>
<h1 id="enabling-recon"><a class="header" href="#enabling-recon">Enabling Recon</a></h1>
<p>You can also use Recon for reconciliation by setting 'CERAMIC_ONE_RECON' env variable to true. </p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  ceramic:
    - ipfs:
        rust:
          env:
            CERAMIC_ONE_RECON: &quot;true&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h1>
<p>You can enable monitoring on a network to deploy jaeger, prometheus and an opentelemetry collector into the network namespace.
This is not the only way to monitor network resources but it is built in.</p>
<p>Metrics from all pods in the network will be collected.</p>
<p>Sample network resource with monitoring enabled.</p>
<pre><code class="language-yaml"># basic.yaml
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: network-with-monitoring
spec:
  replicas: 2
  monitoring:
    namespaced: true
    podMonitor: true
</code></pre>
<p>To view the metrics and traces port-forward the services:</p>
<pre><code>kubectl port-forward prometheus-0 9090
kubectl port-forward jaeger-0 16686
</code></pre>
<p>Then navigate to http://localhost:9090 for metrics and http://localhost:16686 for traces.</p>
<h2 id="exposed-metrics"><a class="header" href="#exposed-metrics">Exposed Metrics</a></h2>
<p>The opentelemetry collector exposes metrics on two different ports under the <code>otel</code> service:</p>
<ul>
<li>otel:9464 - All metrics collected</li>
<li>otel:9465 - Only simulation metrics</li>
</ul>
<p>Simulations will publish specific summary metrics about the simulation run.
This is typically a collection of metrics per simulation run and is much lighter weight than all metrics from all pods in the network.</p>
<p>Scrape the <code>otel:9465</code> endpoint if you want on the simulation metrics.</p>
<blockquote>
<p>NOTE: The prometheus-0 pod will scrape all metrics so you can easily inspect all activity on the network.</p>
</blockquote>
<h2 id="pod-monitoring"><a class="header" href="#pod-monitoring">Pod Monitoring</a></h2>
<p>This option expects the <code>PodMonitor</code> custom resource definition to already be installed in the network namespace.</p>
<p>If <code>podMonitor</code> is enabled, the operator will create <code>podmonitors.monitoring.coreos.com</code> resources for collecting the metrics from the pods in the network.</p>
<p>If you're using something like the grafana cloud agent, or prometheus-operator, the <code>podmonitors.monitoring.coreos.com</code> will be installed already.</p>
<p>You can install the CRD directly from the operator:</p>
<pre><code>    kubectl apply -f https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/main/example/prometheus-operator-crd/monitoring.coreos.com_podmonitors.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h1>
<p>The IPFS behavior used by CAS and Ceramic can be customized using the same IPFS spec.</p>
<h2 id="rust-ipfs"><a class="header" href="#rust-ipfs">Rust IPFS</a></h2>
<h3 id="ceramic"><a class="header" href="#ceramic">Ceramic</a></h3>
<p>Example <a href="./setup_network.html">network config</a> that uses Rust based IPFS (i.e. ceramic-one) with its defaults for Ceramic.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-vanilla-ceramic-one
spec:
  replicas: 5
  ceramic:
    - ipfs:
        rust: {}
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Rust based IPFS (i.e. ceramic-one) with a specific image for Ceramic.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-ceramic-one
spec:
  replicas: 5
  ceramic:
    - ipfs:
       rust:
         image: rust-ceramic/ceramic-one:dev
         imagePullPolicy: IfNotPresent
</code></pre>
<h3 id="cas"><a class="header" href="#cas">CAS</a></h3>
<p>Example <a href="./setup_network.html">network config</a> that uses Rust based IPFS (i.e. ceramic-one) with a specific image for CAS.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-vanilla-ceramic-one
spec:
  replicas: 5
  cas:
    ipfs:
      rust: {}
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Rust based IPFS (i.e. ceramic-one) with a specific image for CAS.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-ceramic-one
spec:
  replicas: 5
  cas:
    ipfs:
     rust:
       image: rust-ceramic/ceramic-one:dev
       imagePullPolicy: IfNotPresent
</code></pre>
<h2 id="kubo-ipfs"><a class="header" href="#kubo-ipfs">Kubo IPFS</a></h2>
<h3 id="ceramic-1"><a class="header" href="#ceramic-1">Ceramic</a></h3>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with its defaults for Ceramic.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-vanilla-kubo
spec:
  replicas: 5
  ceramic:
    - ipfs:
        go: {}
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with a specific image for Ceramic.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-kubo
spec:
  replicas: 5
  ceramic:
    - ipfs:
       go:
         image: ceramicnetwork/go-ipfs-daemon:develop
         imagePullPolicy: IfNotPresent
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with extra configuration commands for Ceramic.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-kubo
spec:
  replicas: 5
  ceramic:
    - ipfs:
       go:
         image: ceramicnetwork/go-ipfs-daemon:develop
         imagePullPolicy: IfNotPresent
         commands:
           - ipfs config --json Swarm.RelayClient.Enabled false
</code></pre>
<h3 id="cas-1"><a class="header" href="#cas-1">CAS</a></h3>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with its defaults for CAS.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-vanilla-kubo
spec:
  replicas: 5
  cas:
    ipfs:
      go: {}
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with a specific image for CAS.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-kubo
spec:
  replicas: 5
  cas:
    ipfs:
     go:
       image: ceramicnetwork/go-ipfs-daemon:develop
       imagePullPolicy: IfNotPresent
</code></pre>
<p>Example <a href="./setup_network.html">network config</a> that uses Go based IPFS (i.e. Kubo) with extra configuration commands for CAS.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: example-custom-kubo
spec:
  replicas: 5
  cas:
    ipfs:
     go:
       image: ceramicnetwork/go-ipfs-daemon:develop
       imagePullPolicy: IfNotPresent
       commands:
         - ipfs config --json Swarm.RelayClient.Enabled false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixed-networks"><a class="header" href="#mixed-networks">Mixed Networks</a></h1>
<p>It is possible to configure multiple sets of Ceramic nodes that different from one another.
For example a network where half of the nodes are running a different version of js-ceramic or IPFS.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="mixed-ipfs"><a class="header" href="#mixed-ipfs">Mixed IPFS</a></h3>
<p>The following config creates a network with half of the nodes running Rust based IPFS and the other half Go.</p>
<pre><code class="language-yaml">---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: mixed
spec:
  replicas: 5
  ceramic:
    - ipfs:
        rust: {}
    - ipfs:
        go: {}
</code></pre>
<h3 id="mixed-js-ceramic"><a class="header" href="#mixed-js-ceramic">Mixed js-ceramic</a></h3>
<p>The following config creates a network with half of the nodes running a <code>dev-0</code> of js-ceramic and the other half <code>dev-1</code>.</p>
<pre><code class="language-yaml">---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: mixed
spec:
  replicas: 5
  ceramic:
    - image: ceramicnetwork/composedb:dev-0
    - image: ceramicnetwork/composedb:dev-1
</code></pre>
<h2 id="weights"><a class="header" href="#weights">Weights</a></h2>
<p>Weights can be used to determine how many replicas of each Ceramic spec are created.
The total network replicas are spread across each Ceramic spec according to its relative weight.</p>
<p>The default <code>weight</code> is <code>1</code>.
The simplist way to get exact replica counts is to have the weights sum to the replica count.
Then each Ceramic spec will have a number of replicas equal to its weight.
However it can be tedious to ensure weights always add up to the replica count so this is not required.</p>
<p>The total replicas all Ceramic specs will always sum to the configured replica count.
As such some rounding will be applied to get a good approximation of the relative weights.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>Create 2/3rd nodes with <code>dev-0</code> and 1/3rd with <code>dev-1</code>.</p>
<pre><code class="language-yaml">---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: mixed
spec:
  replicas: 3
  ceramic:
    - weight: 2
      image: ceramicnetwork/composedb:dev-0 # 2 replicas
    - image: ceramicnetwork/composedb:dev-1 # 1 replica
</code></pre>
<p>Create 3/4ths nodes with <code>dev-0</code> and 1/4rd with <code>dev-1</code>.</p>
<pre><code class="language-yaml">---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: mixed
spec:
  replicas: 24
  ceramic:
    - weight: 3
      image: ceramicnetwork/composedb:dev-0 # 18 replicas
    - image: ceramicnetwork/composedb:dev-1 #  6 replicas
</code></pre>
<p>Create three different version each having half the previous.
In this case weights do not devide evenly so a close approximation is achived.</p>
<pre><code class="language-yaml">---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: mixed
spec:
  replicas: 16
  ceramic:
    - weight: 4
      image: ceramicnetwork/composedb:dev-0 # 10 replicas
    - weight: 2
      image: ceramicnetwork/composedb:dev-1 # 4 replicas
    - weight: 1
      image: ceramicnetwork/composedb:dev-2 # 2 replicas
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-a-ceramic-admin-secret"><a class="header" href="#specifying-a-ceramic-admin-secret">Specifying a Ceramic admin secret</a></h1>
<p>You can choose to specify a private key for the Ceramic nodes to use as their admin secret. This will allow you to set
up the corresponding DID with CAS Auth.</p>
<p>Leaving the private key unspecified will cause a new key to be randomly generated. This can be fine for simulation runs
against CAS/Ganache running locally within the cluster but not for simulations that hit CAS running behind the AWS API
Gateway. Using an unauthorized DID in that case will prevent the Ceramic nodes from starting up.</p>
<pre><code class="language-yaml">apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  privateKeySecret: &quot;small&quot;
</code></pre>
<p>Note that <code>privateKeySecret</code> is the name of another k8s secret in the <code>keramik</code> namespace that has already been
populated beforehand with the desired hex-encoded private key. This source secret MUST exist before it can be used to
populate the Ceramic admin secret.</p>
<pre><code class="language-shell">kubectl create secret generic small --from-literal=private-key=0e3b57bb4d269b6707019f75fe82fe06b1180dd762f183e96cab634e38d6e57b
</code></pre>
<p>The secret can also be created from a file containing the private key.</p>
<pre><code class="language-shell">kubectl create secret generic small --from-file=private-key=./my_secret
</code></pre>
<p>Here's an example of the contents of the <code>my_secret</code> file. Please make sure that there are no newlines at the end of
the file.</p>
<pre><code>0e3b57bb4d269b6707019f75fe82fe06b1180dd762f183e96cab634e38d6e57b
</code></pre>
<p>Alternatively, you can use a <code>kustomization.yml</code> file to create the secret from a file before creating the network, and
using the name of the new secret in the network configuration.</p>
<pre><code class="language-yaml">---
namespace: keramik

secretGenerator:
- name: small
  envs:
  - .env.secret
</code></pre>
<p>Here's an example of the contents of the <code>.env.secret</code> file.</p>
<pre><code>private-key=0e3b57bb4d269b6707019f75fe82fe06b1180dd762f183e96cab634e38d6e57b
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-patterns"><a class="header" href="#operator-patterns">Operator Patterns</a></h1>
<p>This document discusses some of the designs patterns of the operator.</p>
<h2 id="specs-statuses-and-configs"><a class="header" href="#specs-statuses-and-configs">Specs, Statuses, and Configs</a></h2>
<p>The operator is responsible to managing many resources and controlling how those resources can be customized.
As a result the operator adopts a specs, statuses and configs pattern.</p>
<ul>
<li>Specs - Defines the desired state.</li>
<li>Statuses - Reports the current state.</li>
<li>Configs - Custom configuration to control creating a Spec.</li>
</ul>
<p>Both specs and statuses are native concepts to Kubernetes.
A spec provides the user facing API for defining their desired state.
A status reports on the actual state.
This code base introduces the concept of a config.</p>
<p>Naturally, operators wrap existing specs and hide some of their details.
However some of those details should be exposed to the user.
A config defines how the parts of a spec owned by the operator can be exposed.
In turn the configs themselves have their own specs, i.e. the API into how to customize internal specs of the operator.</p>
<p>For example the <code>bootstrap</code> job requires <code>JobSpec</code> to run the job.
The bootstrap job is responsible for telling new peers in the network about existing peers.
Exposing the <code>JobSpec</code> to the user puts too much onus on the user to create a functional job.
Instead we define a <code>BootstrapSpec</code>, a <code>BootstrapConfig</code> and a function that can create the necessary <code>JobSpec</code> given a <code>BootstrapConfig</code>.
The <code>BootstrapSpec</code> is the user API for controlling the bootstrap job.
The <code>BootstrapConfig</code> controls which properties of the <code>JobSpec</code> can be customized and provides sane defaults.</p>
<p>Let's see how this plays out in the code.
Here is a simplified example of the bootstrap job that allows customizing only the image and bootstrap method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BootstrapSpec defines how the network bootstrap process should proceed.
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
pub struct BootstrapSpec {
    // Note, both image and method are optional as the user
    // may want to specify only one or the other or both.
    pub image: Option&lt;String&gt;,
    pub method: Option&lt;String&gt;,
}
// BootstrapConfig defines which properties of the JobSpec can be customized.
pub struct BootstrapConfig {
    // Note, neither image nor method are optional as we need
    // valid values in order to build the JobSpec.
    pub image: String,
    pub method: String,
}
// Define clear defaults for the config.
impl Default for BootstrapConfig {
    fn default() -&gt; Self {
        Self {
            image: &quot;public.ecr.aws/r5b3e0r5/3box/keramik-runner&quot;.to_owned(),
            method: &quot;ring&quot;.to_owned(),
        }
    }
}
// Implement a conversion from the spec to the config applying defaults.
impl From&lt;BootstrapSpec&gt; for BootstrapConfig {
    fn from(value: BootstrapSpec) -&gt; Self {
        let default = Self::default();
        Self {
            image: value.image.unwrap_or(default.image),
            method: value.method.unwrap_or(default.method),
        }
    }
}
// Additionally implement the conversion for the case we the entire spec was left undefined.
impl From&lt;Option&lt;BootstrapSpec&gt;&gt; for BootstrapConfig {
    fn from(value: Option&lt;BootstrapSpec&gt;) -&gt; Self {
        match value {
            Some(spec) =&gt; spec.into(),
            None =&gt; BootstrapConfig::default(),
        }
    }
}
// Define a function that can produce a JobSpec from a config.
pub fn bootstrap_job_spec(config: impl Into&lt;BootstrapConfig&gt;) -&gt; JobSpec {
    let config: BootstrapConfig = config.into();
    // Define the JobSpec using the config, implementation elided.
}
<span class="boring">}
</span></code></pre></pre>
<p>Now for the operator reconcile loop we can simply add the <code>BootstrapSpec</code> spec to the top level <code>NetworkSpec</code> and construct a <code>JobSpec</code> to apply.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NetworkSpec {
    pub replicas: i32,
    pub bootstrap: Option&lt;BootstrapSpec&gt;,
    // ...
}

pub async fn reconcile(network: Arc&lt;Network&gt;, cx: Arc&lt;ContextData&gt;) -&gt; Result&lt;Action, Error&gt; {
    // ...

    // Now with a single line we go from user defined spec to complete JobSpec
    let spec: JobSpec = bootstrap_job_spec(network.spec().bootstrap);
    apply_job(cx.clone(), ns, network.clone(), BOOTSTRAP_JOB_NAME, spec).await?;

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>With this pattern it now becomes easy to add more functionallity to the operator by adding a new field to the config and mapping it to the spec.
Additionally by defining the defaults on the config type there is one clear location where defaults are defined and applied, instead of scattering them through the implementation of the spec construction function or elsewhere.</p>
<h2 id="assembled-nodes"><a class="header" href="#assembled-nodes">Assembled Nodes</a></h2>
<p>Another pattern the operator leverages is to assemble the set of nodes instead of relying on determistic behaviors to assume information about nodes.
Assembly is more robust as it is explicit about node information.</p>
<p>In practice this means the operator produces a <code>keramik-peers</code> config map for each network.
The config map contains a key <code>peers.json</code> which is the JSON serialization of all ready peers with their p2p address and rpc address.
It is expected that other systems consume that config map in order to learn about peers in the network.
The <code>runner</code> does exactly this inorder to bootstrap the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-tests"><a class="header" href="#migration-tests">Migration Tests</a></h1>
<p>The Rust Ceramic migration tests can be executed against a Keramik network by applying the configuration from
<code>/k8s/tests</code>. The network and tests run in the <code>keramik-migration-tests</code> namespace but this can be easily changed.</p>
<p>The URLs of the Ceramic nodes in the network are injected into the test environment so that tests are able to hit the
Ceramic API endpoints.</p>
<p>These tests are intended to cover things like Kubo vs. Rust Ceramic API correctness/compatibility, mixed network
operation, longevity tests across updates and releases, etc. Eventually, they can be used to run smoke tests, additional
e2e tests, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-bootstrap-configuration"><a class="header" href="#advanced-bootstrap-configuration">Advanced Bootstrap Configuration</a></h1>
<h2 id="disable-bootstrap"><a class="header" href="#disable-bootstrap">Disable Bootstrap</a></h2>
<p>By default, Keramik will connect all IPFS peers to each other.
This can be disabled using specific bootstrap configuration:</p>
<pre><code class="language-yaml"># network configuration
---
apiVersion: &quot;keramik.3box.io/v1alpha1&quot;
kind: Network
metadata:
  name: small
spec:
  replicas: 2
  bootstrap:
    enabled: false
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
